### **알고리즘 디자인 실력 증진 방법**

- **개발자에게 있어 알고리즘은 평생의 숙제**

- **어려운 문제를 풀면, 해법의 통찰만을 유지하고, 새로 푼다.**
    - 우선적으로는 **40분~1시간가량 레퍼런스 코드 없이** 문제를 풀어보고,
    - **충분히 고민 후** 문제풀이가 잘 안되면 레퍼런스 코드를 확인
    - **코드를 지우고 다시 푼다**

- **해법이 내가 희망하는 만큼 명료하고, 직접적일 때까지 반복하라.**
    - 앞에서 배운 [수도코드](https://urclass.codestates.com/ad7b1ab8-ab45-4705-b248-d9eaab8a7f96?playlist=522)를 활용하여 문제를 푼다.
    - 레퍼런스 코드를 수도코드화
    - **자신의 수도코드와 어떤 차이**가 있는지 비교

- **비슷한 문제를 공략할 일반적인 룰을 찾아라.**
    - 알고리즘 문제를 풀게 되면 다른 문제라 하더라도 **비슷한 수도코드 or 방법**으로 해결가능
    - 조금 더 심화적으로 접근을 하면, **수학적 사고방식**으로 문제들을 단순화
        - 예. **수학적 귀납법을 이용한 팩토리얼 구하는 알고리즘**
            - 수학적 귀납법이란? 어떤 명제 `P`가 있을 때 다음 2가지만 충족시키면 모든 자연수에 대해서 `P`가 성립한다는 것을 의미

```
<수학적 귀납법>
P(1)은 참이다
P(n)이 참이면 P(n + 1)도 참이다.
그러므로 명제 P는 모든 자연수에 대해서 참이다.

<팩토리얼 구하는 알고리즘>
function factorial (n) {
  if (n < 1) {
    return 1;
  }
  else {
    return n * factorial(n - 1);
  }
}

1. n = 0인 경우 n! = 1이다.
2. n! = n * (n - 1) * (n - 2) * ... 3 * 2 * 1 이다.
3. (n + 1) * n! = (n + 1) * n * (n - 1) * ... 3 * 2 * 1 이다.
그러므로 이 논리는 참이다.
```
  
reference
(https://urclass.codestates.com/)
