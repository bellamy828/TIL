# Linked list

데이터의 값과 다음 Node의 address를 저장할 수 있는 Node라는 구조체가 

메모리상에는 비연속적으로 저장되지만 다음 Node의 주소를 참조함으로써 논리적인 연속성을 갖는 자료구조

## 특징

- 장점
    - 메모리상에서 물리적으로 연속 저장하지 않아도 되므로 메모리 사용이 좀 더 자유롭습니다.
- 단점
    - 다음 참조할 address를 추가적으로 저장하기 때문에 각 데이터가 차지하는 메모리가 더 큽니다.

## 시간복잡도

- Array의 경우 데이터 나열 중간에서 데이터를 삽입/삭제하면 해당 인덱스 이후의 원소는 모두 shift해야하지만,  
Linked list에서는 데이터 나열 중간의 데이터를 삽입/삭제를 해도 다음 참조할 주소값만 변경하면 되므로 O(1)의 시간복잡도를 가집니다.

|  | Array | Linked list |
| :---: | --- | --- |
| 메모리에 저장하는 방식 | 메모리 상에 연속적으로 데이터 저장 | 물리적으로 연속적으로 저장X, 각 Node에 다음 Node의 주소 저장하여 논리적인 연속성 가짐 |
| 데이터 조회 | index에 접근할 때 주소값과 offset을 가지고 random axccess 가능하여 빠름(O(1)) | 연속적으로 저장되지 않았기 때문에 순차적으로 데이터에 접근해야 함(O(n))  |
| 데이터 삽입 / 삭제 | 마지막 인덱스에 요소 추가/삭제는 O(1),  배열 중간에서는 추가/삭제한 index 이후의 데이터 수 만큼 한 칸씩 shift 해야하므로 (O(n)) | 다음 node의 address만 변경하면 되므로 O(1)이지만, 사실상 해당 index 까지 도달하는데 O(n)의 복잡도를 갖기때문에 결과적으로는 O(n) |
| 메모리 효율 | 배열 선언시 메모리를 온전히 다 사용하지 않더라도 fixed size로 일정 용량을 할당하고 있기 때문에 메모리 낭비할 수 있음 | runtime[^1] 중에도 size를 변경할 수 있기 때문에 initial size 고민하지 않아도 되고, 메모리 낭비가 상대적으로 적음 |
| 적합한 작업 | - 저장할 데이터의 양을 예측 가능할 때 <br> - 조회를 많이 하는 작업 <br> - 반복문으로 데이터를 빠르게 순회하는 작업 <br> - 데이터의 양을 알고 있다면 필요한 만큼만 메모리 할당하여 메모리 공간을 효율적으로 활용할 수 있음 <br> cf)Linked list 개별 데이터는 next address를 갖기 때문에 상대적으로 크기가 큼 | - 데이터를 얼마나 저장할지 불확실할 때 <br> - 상대적으로 조회를 많이 하지 않는 작업 <br> - 삽입과 삭제를 많이 하는 작업 |

<br>

  
Reference(https://www.nossi.dev/interview/cs/dsa)

[^1]: runtime: 컴파일 과정을 마친 프로그램이 동작되어지는 때  
(Reference: [https://spaghetti-code.tistory.com/35](https://spaghetti-code.tistory.com/35))
